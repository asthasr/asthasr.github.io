<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.68.3" />

  
  <meta name="description" content="Opinions and discussions of various topics, mostly related to programming.">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://asthasr.github.io/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://asthasr.github.io/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://asthasr.github.io/favicon-16x16.png">

  
  <link rel="manifest" href="https://asthasr.github.io/site.webmanifest">

  
  <link rel="mask-icon" href="https://asthasr.github.io/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://asthasr.github.io/css/bootstrap.min.css" />

  
  <title>The Danger of &#34;Simplicity&#34; | data Blog = Blog { me :: Programmer, posts :: [Opinion] }</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #f8fafc;
}



body {
  color: #294656;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #a9c6d6;
}



.custom-navbar a {
  color: #294656;
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}


div.title {
    font-family: monospace;
    size: 600%;
    padding: 10px;
    background-color: #294656;
    color: #f8fafc;
}
</style>

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Danger of &#34;Simplicity&#34;"/>
<meta name="twitter:description" content="There are a few tendencies among programmers that involve the totem of &ldquo;simplicity.&rdquo; There&rsquo;s the ancient concept of KISS, of course, but there&rsquo;s also the much-abused YAGNI, the insistence that we &ldquo;Choose Boring Technology,&quot; entire languages that base their elevator pitch around the idea that they&rsquo;re &ldquo;simple,&rdquo; and the concept in object-oriented design that &ldquo;every class should have a single responsibility.&rdquo;
The problem with these approaches is that &ldquo;simplicity&rdquo; never gets a rigorous definition."/>


  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZEELKPFTWV"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZEELKPFTWV');
  </script>
</head>


<body>
  <script>MathJax = {tex: { inlineMath: [['$', '$']] }};</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<div class="title">
    data Blog = Blog { me :: Programmer, posts :: [Opinion] }
</div>
<nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>

  
  <div class="container">
    <article>
      <h1>The Danger of &ldquo;Simplicity&rdquo;</h1>
<p>There are a few tendencies among programmers that involve the totem of
&ldquo;simplicity.&rdquo; There&rsquo;s the ancient concept of KISS, of course, but there&rsquo;s also the
much-abused <a href="https://www.martinfowler.com/bliki/Yagni.html">YAGNI</a>, the insistence that we
<a href="https://mcfunley.com/choose-boring-technology">&ldquo;Choose Boring Technology,&quot;</a> entire
languages that base their elevator pitch around the idea that they&rsquo;re &ldquo;simple,&rdquo; and the
concept in object-oriented design that &ldquo;every class should have a single
responsibility.&rdquo;</p>
<p>The problem with these approaches is that &ldquo;simplicity&rdquo; never gets a rigorous definition.
The rhetoric around them is tautological: &ldquo;Do the simple thing.&rdquo; &ldquo;Which one is that?&rdquo;
&ldquo;The simple one, isn&rsquo;t it obvious?&rdquo; If you disagree with the assessment of what
constitutes simplicity, you&rsquo;re met with incredulity. &ldquo;What do you <em>mean</em>, you think Go&rsquo;s
error handling is bad? It&rsquo;s <em>simple!</em>&rdquo; How can we make this less confrontational? How
can we articulate a position more powerful than &ldquo;syntax highlighting is juvenile?&rdquo;</p>
<h2 id="the-purpose-of-programming">The Purpose of Programming</h2>
<p>It&rsquo;s easy to get lost in minutiae. Who hasn&rsquo;t shaved a yak? Still, the ultimate purpose
of programming as a profession or hobby is clear: we want to apply the raw power of
computation to a problem, and know that the &ldquo;recipe&rdquo; we&rsquo;ve written can be trusted to
solve the problem we think that it does.  Code, in itself, is not an asset. A solved
problem is an asset.</p>
<p>The types of programs that we need to deliver, their performance models, their failure
modes, and the methods we can use to understand them are all different depending on the
environment in which we work, but the need for trust in our programs is universal. I
think the worst fear for a programmer is a program that not only <em>misbehaves</em>, but also
<em>misbehaves in ways we don&rsquo;t understand</em>. We want tools that do what they&rsquo;re supposed to
do, or, if they can&rsquo;t, that fail predictably in ways that we can quickly understand and
fix.</p>
<p>When someone argues for &ldquo;simplicity,&rdquo; they are almost always arguing implicitly for
concepts that they believe improve the possibility of trustworthiness. The problem
emerges when programmers of all types forget that their preferred model of success does
not apply to all types of programs, and each choice imposes costs.</p>
<h2 id="what-are-we-optimizing-for">What are we optimizing for?</h2>
<p>The creators of Go have said, sometimes in pejorative terms,<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> that &ldquo;average
programmers&rdquo; have difficulty understanding complex languages, and have set themselves
against that complexity by designing one with a relatively small syntactic grammar,
error handling based on return codes, and no generics. They looked at the landscape of
&ldquo;complicated&rdquo; languages and decided that the form of simplicity that they&rsquo;d optimize for
would be the initial learning curve.</p>
<p>On the other hand, Rust&rsquo;s designers aimed at a different concept of simplicity. They
wanted to protect users from the types of memory errors that have led to countless CVEs
and bugs in C and C++ programs. They did so by embracing the type-theoretic concept of
&ldquo;affine types,&rdquo; called &ldquo;lifetimes&rdquo; in Rust.<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> They also eliminated the traditional
idea of null<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> by making Haskell-like <code>Result</code> and <code>Option</code> types core to the
language.</p>
<p>Both of these decisions, in major modern languages, solve certain classes of
problems&mdash;and both pay a price for their choices. Go&rsquo;s error handling has become a
<a href="https://pbs.twimg.com/media/DCIF7-2W0AEAv9c.jpg">meme</a>, for example. Articles to help
with understanding lifetimes in Rust are nearly as ubiquitous as monad tutorials for the
aspiring Haskeller, and it turns out that a lot of important data structures are pretty
hard to implement when you have to worry about them. Still, you can&rsquo;t say that either
language has failed in its goals&mdash;it&rsquo;s just that each has chosen different tradeoffs.</p>
<p>In other words: every decision made in order to simplify a program will cost something.</p>
<h2 id="down-to-earth">Down to Earth</h2>
<p>Most programmers aren&rsquo;t writing programming languages, so the choice of &ldquo;what to
simplify&rdquo; may seem esoteric, but it&rsquo;s not. Consider data serialization. When you first
implement a web service, it can seem &ldquo;simple&rdquo; to model both deserialization and
serialization using the same objects. Then, since you&rsquo;re implementing something new, you
naturally want to keep it <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>,
so you hook up your serialization library to your ORM models.</p>
<p>Then it turns out that you need to add a field to a table for batch processing and omit
that from emitted JSON.  Then it turns out that the enormous client that is going to pay
your salaries for the next three years <em>really</em> needs XML output.  Then it turns out
that the <em>other</em> client, the one owned by your main investor&rsquo;s brother, is intrinsically
incapable of sending in any input other than DOS-formatted CSVs, for some reason.</p>
<p>Suddenly, it looks like unifying serialization, deserialization, and persistence
involved a few more tradeoffs than it seemed when you were writing <code>class Widget:</code> in
that fresh new git repository, right?</p>
<h2 id="the-elusive-universal">The Elusive Universal</h2>
<p>If everything is a tradeoff, how do we make any decision about the design of our
software at all? It&rsquo;s tempting to make hard and fast rules. There are plenty of those:
&ldquo;Methods should never have more than five lines of code,&rdquo; &ldquo;no line of code should be
written without a unit test,&rdquo; or &ldquo;all production code is pair programmed.&rdquo; What this is
doing, though, is <em>hiding</em> the choice from you (or lying about it). It&rsquo;s not that the
choice wasn&rsquo;t made, it&rsquo;s that someone else made it, and now wants to convince you that
their opinion has no cost.</p>
<p>Instead of accepting this at face value, instead think about <em>how</em> to make those choices
for yourself. Think about the different ways that code can be simple, and the things to
which that particular simplicity is opposed.</p>
<p>For example, dynamically typed languages like Python (or Ruby, Lisp, etc.) are easy and
pleasant to write. They avoid the difficulty of convincing a compiler that you&rsquo;ve
written your code correctly, but they&rsquo;re harder for a new team member to comprehend:
you&rsquo;re trading fluent writing for more laborious reading.</p>
<p>Short functions, methods, and classes are quick to read, but must either be built of
many lower-level functions or themselves comprise parts of larger compositions in order
to accomplish anything. You&rsquo;re trading away locality in favor of concision.</p>
<p>Error codes are easier to understand than exceptions or <code>Result</code> types, but they don&rsquo;t
carry much information. You&rsquo;re trading ease of comprehension for difficulty of
debugging. Exceptions carry a great deal of information but break the sequentiality of
the code. Result types can carry information <em>and</em> preserve sequentiality, but can
require a lot of &ldquo;plumbing&rdquo; in order to compose and handle different types of errors.</p>
<p>Each of these examples illustrates choices you need to make. You can reduce the number
of things you care about to help with making them: limiting your choice of programming
languages to a particular set, committing to use automatic formatters, or standardizing
on a DevOps toolchain can all help to reduce the number of decisions that need to be
made. In the end, though, it will come down to <em>how should I implement this feature?</em>
and you&rsquo;ll make better decisions about that if you understand that <em>simplicity is not
simple.</em></p>
<p>And that you should not trust anyone who claims it is.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>It&rsquo;s inflammatory, but the article <a href="http://nomad.uk.net/articles/why-gos-design-is-a-disservice-to-intelligent-programmers.html">&ldquo;Why Go&rsquo;s design is a disservice to intelligent programmers&rdquo;</a> is worth reading just for the quotes from Rob Pike. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Consider reading the three chapters <a href="https://doc.rust-lang.org/1.9.0/book/ownership.html">&ldquo;Ownership,&quot;</a> <a href="https://doc.rust-lang.org/1.9.0/book/references-and-borrowing.html">&ldquo;References and Borrowing,&quot;</a> and <a href="https://doc.rust-lang.org/1.9.0/book/lifetimes.html">&ldquo;Lifetimes&rdquo;</a> from the online Rust Book, if you want to understand this concept. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Tony Hoare&rsquo;s presentation on the subject, <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">&ldquo;The Billion Dollar Mistake,&quot;</a> is a great talk and explains why they&rsquo;d <em>want</em> to do something so weird. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

    </article>
  </div>

  
  
  

  

  
</body>

</html>
